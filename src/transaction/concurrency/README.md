---
author: antio2
date: 2023年8月19日
---
## 框架概览

之前为了实现可串行化，采用了直接加表锁加上严格的2PL加锁策略。但是这样导致并发性太低。

为了提高并发性，将锁的策略改成了行锁+gap lock的形式，因为没见过其他数据库的gap lock源码是如何实现的，这里是我自己的理解。

在RR事务可串行化过程中，需要在写时对行加X锁，在读取时加S锁并一直持有S锁直到事务结束。这样就可以保证读过的行不会被其他事务修改，可以再次读取。

但是随之而来的幻读的问题：如果只对已有行加锁，对于新插入的行，该事务是没有持有锁的。也就是说，在RR的隔离级别下，重复读可能读多出来的Insert行。

为了解决这个问题，之前的解决方法是将数据库的隔离级别提升至可串行化。而这种方法的缺点如前述，并发性太低。

而如果所有select,和DML操作都在索引上进行，可以使用索引上的gap lock来解决幻读问题
