---
author: antio2
date: 2023年8月19日
---
## 框架概览

之前为了实现可串行化，采用了直接加表锁加上严格的2PL加锁策略。但是这样导致并发性太低。

为了提高并发性，将锁的策略改成了行锁+gap lock的形式，因为没见过其他数据库的gap lock源码是如何实现的，这里是我自己的理解。

在RR事务可串行化过程中，需要在写时对行加X锁，在读取时加S锁并一直持有S锁直到事务结束。这样就可以保证读过的行不会被其他事务修改，可以再次读取。

但是随之而来的幻读的问题：如果只对已有行加锁，对于新插入的行，该事务是没有持有锁的。也就是说，在RR的隔离级别下，重复读可能读多出来的Insert行。

为了解决这个问题，之前的解决方法是将数据库的隔离级别提升至可串行化。而这种方法的缺点如前述，并发性太低。

而如果所有select,和DML操作都在索引上进行，可以使用索引上的gap lock来解决幻读问题

## 测试

|        | 读已提交 | 重复读                              | 幻读 |
| ------ | -------- | ----------------------------------- | ---- |
| 无索引 | √        | √ （select 过的列不能被修改或删除） | ×    |
|        |          |                                     |      |
|        |          |                                     |      |

### 写丢失

```
create table t(id int, age int);
insert into t values(1,19);
insert into t values(2,16);
t1 begin;
t1 delete from t;
t2 begin;
t2 insert into t values(3,19);
t2 insert into t values(4,16);
t1 abort;
```

本来t2应该能够正常插入，但是因为delete占用了空的rid，insert尝试插入空的rid，造成X锁冲突。

解决方法：

在Commit阶段再进行实际上的delete操作（标记bitmap）。在执行器期间只记录写操作。但是这样会造成一个问题，就是删除操作会对事务本身不可见。比如先delete，再select。

解决方法是delete时不对rid加锁。
